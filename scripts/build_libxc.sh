#!/bin/bash

# 构建libxc.a的脚本

# 确保脚本在错误时退出
set -e

# 获取脚本所在目录的上级目录（项目根目录）
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# 设置源代码和输出目录
SRC_DIR="${PROJECT_ROOT}/src"
INCLUDE_DIR="${PROJECT_ROOT}/include"
LIB_DIR="${PROJECT_ROOT}/lib"
TMP_DIR="${PROJECT_ROOT}/tmp"

# 设置编译器，可通过环境变量覆盖
COSMOCC="${COSMOCC:-$(command -v cosmocc 2>/dev/null || command -v cc)}"
AR="${AR:-$(command -v cosmoar 2>/dev/null || command -v ar)}"

# 设置编译选项
CFLAGS="-Os -fomit-frame-pointer -fno-pie -fno-pic -fno-common -fno-plt -mcmodel=large -finline-functions -I${SRC_DIR} -I${SRC_DIR}/infrax -I${INCLUDE_DIR}"

# 创建输出目录（如果不存在）
mkdir -p "${LIB_DIR}"
mkdir -p "${INCLUDE_DIR}"
mkdir -p "${TMP_DIR}"

# 获取CPU核心数以确定并行编译数量
# 如果传入了参数，使用参数值作为并行任务数
if [ $# -gt 0 ] && [ "$1" -eq "$1" ] 2>/dev/null; then
    PARALLEL_JOBS=$1
else
    # 否则自动检测
    if [[ "$(uname)" == "Darwin" ]]; then
        PARALLEL_JOBS=$(sysctl -n hw.ncpu)
    else
        PARALLEL_JOBS=$(nproc 2>/dev/null || echo 4)
    fi
fi

echo "检测到 ${PARALLEL_JOBS} 个CPU核心，将使用并行编译"

# 创建一个临时的完整头文件
echo "生成完整的展开头文件 libxc.h..."

# 创建最终的 libxc.h 文件
cat > "${INCLUDE_DIR}/libxc.h" << EOF
//WARNING:DO NOT MODIFY THIS FILE libxc.h MANUALLY, IT IS AUTO GENERATED BY build_libxc.sh
#ifndef LIBXC_H
#define LIBXC_H

#include "cosmopolitan.h"

EOF

# 将 xc.h 中的内容添加到 libxc.h 中，但排除 #include 语句和头文件保护宏
sed -n '/^#ifndef/,/^#include/d; /^#include/d; /^#endif/d; p' "${SRC_DIR}/xc/xc.h" >> "${INCLUDE_DIR}/libxc.h"

# 添加结尾保护宏
echo -e "\n#endif /* LIBXC_H */" >> "${INCLUDE_DIR}/libxc.h"

# 编译XC源文件
echo "编译XC源文件..."

# 编译源文件列表（按依赖顺序排序）
SOURCE_FILES=(
    # infrax层 (TODO expose "arch" or "infrax" later)
    # "${SRC_DIR}/infrax/InfraxCore.c"
    # "${SRC_DIR}/infrax/InfraxMemory.c"
    # "${SRC_DIR}/infrax/InfraxLog.c"
    # "${SRC_DIR}/infrax/InfraxThread.c"
    # "${SRC_DIR}/infrax/InfraxSync.c"
    # "${SRC_DIR}/infrax/InfraxAsync.c"
    # "${SRC_DIR}/infrax/InfraxNet.c"
    
    # 核心运行时
    "${SRC_DIR}/xc/xc.c"
    "${SRC_DIR}/xc/xc_gc.c"
    "${SRC_DIR}/xc/xc_types/xc_exception.c"
    "${SRC_DIR}/xc/xc_types/xc_null.c"
    "${SRC_DIR}/xc/xc_types/xc_boolean.c"
    "${SRC_DIR}/xc/xc_types/xc_number.c"
    "${SRC_DIR}/xc/xc_types/xc_string.c"
    "${SRC_DIR}/xc/xc_types/xc_function.c"
    "${SRC_DIR}/xc/xc_types/xc_array.c"
    "${SRC_DIR}/xc/xc_types/xc_object.c"
    # "${SRC_DIR}/xc/xc_types/xc_vm.c" # higher runtime concepts like JIT/IR/FFI/AST/VM etc...
    
    # 标准库
    "${SRC_DIR}/xc/xc_std/xc_std_console.c"
    "${SRC_DIR}/xc/xc_std/xc_std_math.c"
)

# 直接使用 make 的方式编译各个源文件
echo "开始并行编译..."

# 创建一个临时的 Makefile
TEMP_MAKEFILE=$(mktemp)
cat > "${TEMP_MAKEFILE}" << EOF
.PHONY: all clean

CFLAGS=${CFLAGS}
CC=${COSMOCC}

OBJS =
EOF

# 添加规则到临时 Makefile
for src in "${SOURCE_FILES[@]}"; do
    obj="${src%.c}.o"
    echo "OBJS += ${obj}" >> "${TEMP_MAKEFILE}"
    echo "" >> "${TEMP_MAKEFILE}"
    echo "${obj}: ${src}" >> "${TEMP_MAKEFILE}"
    echo "	@echo 编译 \$<..." >> "${TEMP_MAKEFILE}"
    echo "	@\$(CC) \$(CFLAGS) -c \$< -o \$@" >> "${TEMP_MAKEFILE}"
    echo "	@echo 完成 \$<" >> "${TEMP_MAKEFILE}"
    echo "" >> "${TEMP_MAKEFILE}"
done

# 添加全局目标
cat >> "${TEMP_MAKEFILE}" << EOF
all: \$(OBJS)

clean:
	rm -f \$(OBJS)
EOF

# 使用 make 的并行编译功能
echo "使用 make -j${PARALLEL_JOBS} 进行并行编译..."
make -j${PARALLEL_JOBS} -f "${TEMP_MAKEFILE}" all

# 清理临时文件
rm "${TEMP_MAKEFILE}"

# 收集所有目标文件
OBJECT_FILES=()
for src in "${SOURCE_FILES[@]}"; do
    obj="${src%.c}.o"
    OBJECT_FILES+=("${obj}")
done

# 创建静态库
echo "创建 libxc.a..."
"${AR}" rcs "${LIB_DIR}/libxc.a" "${OBJECT_FILES[@]}"

# 显示文件信息
echo -e "\n生成的静态库信息:"
ls -la "${LIB_DIR}/libxc.a"
ls -la "${INCLUDE_DIR}/libxc.h"

echo "libxc.a和完全展开的libxc.h构建完成!"
